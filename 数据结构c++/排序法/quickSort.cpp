#include<iostream>
using namespace std;
/*
 * 一趟快速排序，以某个值为中心，将序列分成两部分，
 * 一边全是比它小（或小于等于）的值，另一边全是比它大（或大于等于）的值。
 * 
 * 执行流程：
 * 原始序列： 49 38 65 97 13 27 49
 *          i                 j (i,j分别指向头、尾元素)
 * 进行第一趟快速排序，以最后一个数 49 作为中心，整个过程是一个交替扫描和交换的过程
 * 1） 使用 i，从序列最左端向后扫描，直到遇到比 49 大的数 65， i 停下
 * 49 38 65 97 13 27 49
 *       i           j
 * 2) 将 65 交换到序列后端 j 的位置
 * 49 38 ‘’ 97 13 27 65
 *       i           j
 * 3) 使用 j，换扫描方向，从后向前扫描，直到遇到比 49 小的数 27， j 停下
 * 49 38 ‘’ 97 13 27 65 
 *       i        j
 * 4) 将 27 交换到序列前端 i 的位置
 * 49 38 27 97 13 ‘’ 65
 *       i        j
 * 5) 使用i，换扫描方向，从前向后扫描，直到遇到比 49 大的数 97， i停下
 * 49 38 27 97 13 ‘’ 65
 *          i     j
 * 6) 将97交换到序列后端j的位置
 * 49 38 27 ‘’ 13 97 65
 *          i     j
 * 7) 使用 j，换扫描方向，从后向前扫描，直到遇到比 49 小的数 13， j 停下
 * 49 38 27 ‘’ 13 97 65
 *          i  j
 * 8) 将 13 交换到序列前端 i 的位置
 * 49 38 27 13 ‘’ 97 65
 *          i  j
 * 9) 使用 j，换扫描方向，从后向前扫描，当扫描到 i 与 j 相遇时，扫描过程结束
 * 49 38 27 13 ‘’ 97 65
 *             ij
 * 10） 此时 i == j 这个位置，就是中心数 49 的最终位置，将49放入这个位置，第一趟快速排序结束。
 * 49 38 27 13 49 97 65
 *             ij
 */
void QuickSort(int a[], int l, int r)
{
  if( l > r ) return;

  int i = l;
  int j = r;
  int temp = a[j];

  while( i != j )
  {
    while( i < j && a[i] < temp ) ++i;
    if( i < j )
      a[j] = a[i];
      --j;
    while( i < j && a[j] > temp ) --j;
      if( i < j )
        a[i] = a[j];
        ++i;
  }
  a[i] = temp;

  QuickSort( a, l, i - 1 );
  QuickSort( a, i + 1, r );
}