### 如何深入高效地学习语言
* 在比较中学习
* 在历史中学习
* 在实践中学习

### 程序员的三大美德
* 懒惰——为减少总能量支出，不遗余力地努力的素质
* 急躁——忍受不了程序执行的抵消
* 傲慢——容忍不得对错误的不管不顾

### 为什么有流程控制语句？
结构化程序设计导入流程控制语句，使代码结构变得更加简单。

### 为什么有函数？
* 便于理解——如同一个组织
* 便于再利用——如同零部件

### 错误处理的历史
* 1.通过返回值传达出错信息——if(fn() == 0) {// error handle}
  * 遗漏错误
  * 错误处理降低代码可读性
* 2.出错则跳转
* 3.将可能出错的代码括起来的语句结构——try...catch...

### 名字和作用域
用名字指代变量和函数，增加了程序的可读性。

使用动态/静态作用域限制名字有效作用范围。

### 字符
UNICODE是万能编码，包含了所有符号的编码，它规定了所有符号在计算机底层的二进制的表示顺序。有关Unicode为什么会出现就不叙述了，Unicode是针对所有计算机的使用者定义一套统一的编码规范，这样计算机使用者就避免了编码转换的问题。

Unicode定义了所有符号的二进制形式，也就是符号如何在计算机内部存储的，而且每个符号规定都必须使用两个字节来表示，也就是用16位二进制去代表一个符号，这样就导致了一个问题，英文编码的空间浪费，因为在ANSI中的符号都是一个字节来表示的，而使用了UNICODE编码就白白浪费了一个字节。也就代表着Unicode需要使用两倍的空间去存储相应的ANSI编码下的符号。虽然现在硬盘或者内存都很廉价，但是在网络传输中，这个问题就凸显出来了，你可以这样想想，本来1M的带宽在ANSI下可以代表1024*1024个字符，但是在Unicode下却只能代表1024*1024/2个字符。也就是1MB/s的带宽只能等价于512KB/s，这个很可怕啊。

为了解决符号在网络中传输的浪费问题，就出现了UTF-8编码，Unicode transfer format -8 ，后面的8代表是以8位二进制为单位来传输符号的，但是这样又导致了一个问题，虽然UTF-8可以使用一个字节来表示ANSI下的符号，但是对于其它类似汉语的符号，得需要两个字节来表示，所以计算机不知道如何去截取一个符号，也就是一个符号对应的二进制的截取开始位置和截取结束位置。所以为了解决Unicode下的ANSI符号的空间浪费和网络传输下如何截取字符的问题，UTF规定：
* 如果一个符号只占一个字节，那么这个8位字节的第一位就为0。
* 如果为两个字节，那么规定第一个字节的前两位都为1，然后第一个字节的第三位为0，第二个字节的前两位为10，
* 如果是三个字节的话，那么第一个字节的前三位为111，第四位为0，剩余的两个字节的前两位都为10。
  
按照这样的算法去思考一个中文字符的UTF-8是怎么表示的：一个中文字符需要两个字节来表示，两个字节一共是16位，那么UTF-8下，两个字节是不够的，因为两个字节下，第一个字节已经占据了三位：110，然后剩余的一个字节占据了两位：10，现在就只剩下11位，与Unicode下的两个字节，16位去表示任意一个字符是相悖的。所以就使用三个字节去表示非ANSI字符：三个字节下，一共是24位，第一个字节头四位是：1110，后两个字节的前两位都是：10，那么24位-8位=16位，刚好两个字节去表示Unicode下的任意一个非ANSI字符。这也就是为什么UTF-8需要使用三个字节去表示一个非ANSI字符的原因了！

在这里补充一下uft-8的编码方式。
````
一字节：0*******

两字节：110*****，10******

三字节：1110****，10******，10******

四字节：11110***，10******，10******，10******

五字节：111110**，10******，10******，10******，10******

六字节：1111110*，10******，10******，10******，10******，10******
````

### 并发处理
在重叠的时间段内，同时进行的多个处理叫做并发处理。

#### 竞态成立的三个条件
a 两个处理共享变量

b 至少一个处理会对变量进行修改

c 一个处理未完成之前另一个处理有可能介入进来


### 专栏

#### 当你不知道该学习什么时
应该学习什么？我们经常听到这样的问题。在回答之前，笔者想先问这样一个问题：
你学习的目的是什么？这个如果不明确，提建议就无从下手。我们生活在一个信息爆
炸的时代。不管三七二十一统统都学，这样的学习策略已经不再适用。必然要有所
学，有所不学。这时，我们就要事先明确自己到底想做什么，然后再去学习能够达成这一目标的知识。不知道自己要做什么？

或许你从一开始就在苦思，想做一件完美的事情。一件从没有人想到过的，能获得别
人赞誉的事情。如果最初的设想太过宏大导致无从下手，那么这一设想就永远不可能
实现。还不如从小事做起，从简单的事情做起。在这个过程中，你可以逐渐明白自己
哪些已经能做、哪些还不能做，如果要做还要学习哪些知识。长此以往，就能培养出
完成更复杂的任务的能力。

#### 具体的知识和抽象的知识
在语言 X 中如何实现 Y，像这种具体的知识（know-how）可快速提高你的工作效
率。但是一旦语言发生变化，这种知识就无法再使用。世界瞬息万变，这意味着限定
了应用范围的具体知识将慢慢失去其价值。因此，我们不仅要学习具体的知识，更要
有意识地去学习那些应用范围广泛的抽象的概念。

当然，学习了抽象的元知识，如果不将其与你具体的经验相结合，也无法在实际应用
中发挥其作用。喜欢樱花的人即使剪下花开的树枝带回家，终将看到的也仅仅是枝枯
花败的场景而已。要想樱花年年盛开，离开根部和枝干是不行的。

我们所学的知识到底有没有真正的“根基”，可以通过考察能否具体地举例或者具体地
实现来确认。没有真正根基的知识是无法顺藤摸瓜、触类旁通的，所谓学习到的知识
也只能像鹦鹉学舌般的重复讲讲而已。想要因地制宜地活用知识更是缘木求鱼，根本
没有可能了。
专栏

#### 学习讲求细嚼慢咽
一口吞不下一整块肉。首先要把肉切成能入口的大小，嚼碎后再吃。同样的道理，对
抽象的概念、复杂的系统和不习惯的领域，我们也不可能一下子理解通透。首先要把
信息切分，一小块一小块地消化吸收到自己的大脑里。

然而，在信息爆炸时代，如何对信息做取舍呢？什么信息是重要的，什么是不重要
的？要判断什么信息重要首先需要对其有深刻的理解，但如此一来，就陷入到先有蛋
还是先有鸡的困境中了。

身边如果有这熟悉这些信息的人、朋友，向他们请教也是一种方法。但要是没有呢？
在网上检索查询的话，那些发言者是真的熟悉还是装作熟悉呢，这又该如何判断？
作者本人写的文档当然是最为翔实的。但是要么认为难懂，要么认为内容太多，要么
认为看英语有困难，我们总会有各种借口放弃查阅原作者的一手资料，而去寻找那些
写得简单的解说。这就如同，当肉太大、太硬时，转而不顾食品安全，吃起别人做出
来的肉馅。

这种心情是可以理解的。笔者也有在庞大信息量面前心力交瘁的时候。这时有三种战
略可供参考：
* 从需要的地方开始阅读，
* 先掌握概要再阅读细节，
* 从头开始逐章手抄。
