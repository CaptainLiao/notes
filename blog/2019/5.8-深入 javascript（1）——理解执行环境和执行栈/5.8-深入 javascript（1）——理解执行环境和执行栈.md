## 理解 javascript 执行上下文和执行栈
执行上下文和执行栈是 javascript 程序运行的基石，也是理解变量提升、作用域、闭包等概念的关键。

### 执行上下文
执行上下文可以简单的理解为“javascript 代码的运行环境”，它有三种子类型：
* **全局执行上下文**——这是默认的执行上下文。所有不在函数内部的代码都在全局执行上下文中。它做了两件事：1.创建一个全局对象；2.将这个全局对象赋值给 this。在一个程序中，有且只有一个全局执行上下文。
* **函数执行上下文**——每调用一个函数，就会为这个函数创建一个新的执行上下文，接着执行一系列步骤（我们稍后就会提到）。一个程序中可以有任意多个函数执行上下文。
* **Eval 函数执行上下文**——实际上几乎不会用到，就不讨论了。

### 执行栈
执行栈也称“调用栈”，是一个具有先进后出（LIFO）特点的堆栈，用来存储代码执行过程中创建的执行上下文。

当 javascript 引擎开始执行你的脚本时，首先会创建一个全局执行上下文，并将其推入到当前的执行栈中。在后续的脚本执行过程中，只要发生了函数调用，引擎就会为这个函数创建一个新的执行上下文，并推入到栈顶。

引擎会执行那些上下文位于栈顶的函数，当函数执行完毕，它的执行上下文会被弹出。引擎控制器指向下一个执行上下文。

举个例子：
````js
let a = 'Hello World'

function first() {
  console.log('Inside first function')
  second()
  console.log('Again inside first function')
}

function second() {
  console.log('Inside second function')
}

first()
console.log('Inside Global Execution Context')
````
图1
代码运行过程中执行栈的变化过程

假定上面的代码运行在浏览器中。

首先，javascript 引擎创建了一个全局执行上下文并将其推入到当前的执行栈中。调用`first()`时，引擎为它创建了一个新的执行上下文，并将其推入到当前执行栈的栈顶。

当调用`first()`的内部函数`second()`时，javascript 引擎也为其创建了一个新的执行上下文并推入到栈顶。当`second()`执行完毕，立即弹出它的执行上下文。然后控制器指向下一个执行上下文，即`first()`的函数执行上下文。

当`first()`执行完毕，它的执行上下文也被弹出，于是控制器指向了全局执行上下文。一旦执行完所有代码，javascript 引擎会将全局执行上下文从当前栈中抹去。

这就是以上代码在 javascript 内部运行的全部过程，也是其他任何 javascript 代码的执行过程。

我们看到，每个执行上下文都会经历：创建 -> 入栈 -> 执行 -> 出栈四个阶段，象征着一个程序由生到死，我称之为“代码的生命周期”。

等等，代码都执行完了，变量提升、作用域还一根毛都没见着？？？

咱们书说简短，且听下回分解！



