/**
 * 96. 不同的二叉搜索树
 * https://leetcode-cn.com/problems/unique-binary-search-trees/
 * 
 * 【分析】同样使用递归分析三步曲
 * 第一步：假设结论已知
 * 第二步：求通项
 * 第三步：实际编码过程需根据通项，由前往后推算，注意处理边界
 * 
 * 1、假设已知 n-1 个节点组成的二叉搜索树有 f(n-1) 种
 * 2、求由 n 个节点组成的二叉搜索树有多少种？(求通项)
 * 根据二叉搜索树的性质：左子树所有节点小于它的根节点，右子树所有节点大于它的根节点，可以得出：
 *   当根节点为 1，它的左子树节点总数为 0，右子树的节点总数为 n-1，那么以 1 为根节点的二叉搜索树有 f(0) x f(n-1) 种
 *   当根节点为 2，它的左子树节点总数为 1，右子树的节点总数为 n-2，那么以 2 为根节点的二叉搜索树有 f(1) x f(n-2) 种
 *   ......
 *   当根节点为 n，它的左子树节点总数为 n-1，右子树的节点总数为 0，那么以 n 为根节点的二叉搜索树有 f(n-1) x f(0) 种
 * 所以，可得 f(n) = f(0)xf(n-1) + f(1)xf(n-2) + ... + f(n-1)xf(0)
 * 3、分析通项，可通过递归进行计算
 */

function numTrees(n) {
  if (n === 0) return 1

  var i = 0
  var res = 0
  while (i < n) {
    res += numTrees(i) * numTrees(n-i-1)
  }

  return res
}

// 显然，由于上述方法存在大量重复计算，当 n 变大后，会有异常：超出时间限制(time limited exceeded)
// 需要缓存计算结果来进行优化