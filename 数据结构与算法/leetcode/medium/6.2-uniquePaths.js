/**
 * 不同路径
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？
 */

/**
 * [分析]
 * 由题意，不妨用一个二维数组p来表示网格，p中的每一项保存到达对应网格的路径值
 * 再次使用动态规划套路二步曲：
 * 1、假设已知结果：假设总共有x条不同的路径，且p中每一项结果已知
 * 2、由后往前推：由于机器人只能向下或者向右移动一步，
 *    那么最右下角网格的值，等于它左网格的值(p[m][n-1])加上它上网格(p[m-1][n])的值，即p[m][n] = p[m][n-1] + p[m-1][n]
 * 
 * 有了上面分析得来的通项还不够，我们解题需要从前往后进行计算：
 *    初始化m x n的二维数组，每个值为0。
 *    由于初始位置在m x n 网格的左上角，那么显然p[0][0]等于1。
 *    遍历二维数组，通过上面的通项为每一项赋值，p[m-1][n-1]即为最终结果    
 * 
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  var p = Array(m).fill(0).map(() => Array(n).fill(0))
  p[0][0] = 1

  for (var i = 0; i < m; ++i) {
    for (var j = 0; j < n; ++j) {
      if (i - 1 >= 0) p[i][j] += p[i-1][j]
      if (j - 1 >= 0) p[i][j] += p[i][j-1]
    }
  }

  return p[m-1][n-1]
};

// 优化：

// 对于3 x 2的网格，我们可写出每一项的路径总数
// 1 1 1
// 1 2 3

// 那么，4 X 3 的网格呢？
// 1 1 1 1
// 1 2 3 4
// 1 3 6 10

// 5 x 4 呢？
// 1 1 1 1 1
// 1 2 3 4 5
// 1 3 6 10 15
// 1 4 10 20 35

// 原来最后一项的结果，等于最后一行的前 n-1 列元素之和
// 所以我们并不需要 m x n项的二维数组，只需要 n 项一维数组

var uniquePaths2 = function(m, n) {
  if (m === 1 || n === 1) return 1
    
  var p = []
  for (var i = 1; i < m; ++i) {
    for (var j = 1; j < n; ++j) {
      p[j] = (p[j] || 1) + (p[j-1] || 1)
    }
  }
  return p[n-1]
}