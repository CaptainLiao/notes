/**
打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2:
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
*/

/**
普通码农所感受到的【数学之美】

很久之前就听说过吴军博士《数学之美》的大名，但迟迟未读。

什么原因呢？

一提到数学，我脑袋中不免出现“微积分、泰勒公式、无穷级数”等令人无比头痛的概念。它似乎是居学堂之高，离实际之远。

然而前不久读完，真真儿有醍醐灌顶、耳目一新之感。

在《数学之美》中，吴博士将数学原理讲的通俗易懂，并通过实际的例子展示了数学的超级能力。

如书中提到的一系列复杂的工程问题（分词、语音识别、机器翻译等），都被科学家们用数学知识轻松解决。作为非专业人士（我）也看的是津津有味。

我由衷的钦佩那些为人类做出伟大贡献的科学家们，更被数学的强大威力而震撼。

同时不得不为自己的浅薄无知而感到无比羞愧。

作为普通人，是否就不能亲身感受到数学之美么？我这样想。

直到某天，我在做一道算法题——**打家劫舍**：

>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

这是一道关于动态规划的算法题，熟悉的同学可能很快就知道解法，但我在分析过程中切切实实感受到了一把数学之美。分享一下。

【分析】

动态规划的三个特征：
  * 求最优解
  * 具有重复子问题并且子问题之间不独立
  * 当前的决策依赖于前面决策

我们知道，解决动态规划问题的关键，就是【找规律】。通常适用的方法：分析由低阶向高阶推导的过程，从中找出规律。

本题分析过程：
  n = 1，返回“第1项的值”
  n = 2，返回“第2项的值”与“第3项的值”中的最大者
  n = 3，返回"第3项的值+第1项的值"与“第2项的值”中的最大者
  n = 4，返回“第4项的值+第2项的值”的结果与“第1项的值+第3项的值”的结果中的最大值
  ...

仔细分析以上推导过程，如果你能从中发现：
  n = 1时，返回“第1项值 + 数组长度为-1的结果”与“数组长度为0的结果”中的最大者
  n = 2时，返回“第2项值 + 数组长度为0的结果”与“数组长度为1的结果”中的最大者
  n = 3时，返回“第3项值 + 数组长度为1的结果”与“数组长度为2的结果”中的最大者
  ...
  
则，第n项对应的结果 = 第n项的值 + 第n-2项的结果。

那么，问题的答案就变成了——返回第n项结果与第n-1项结果中的最大值。

这一系列的分析过程，从数学角度来看，动态规划不就是**【数学归纳法】**的实际应用吗？
````
f(-1) = f(0) = 0
f(1) = max(array[1] + f(-1), f(0))
f(2) = max(array[2] + f(0), f(1))
f(3) = max(array[3] + f(1), f(2))
...
f(n) = max(array[n] + f(n-2), f(n-1))
````

于是，写代码便成了一件容易的事：
````
int robMax (vector<int> nums) {
    if (nums.empty()) return 0;

    int last = nums[0];
    int current = max(last, nums[1]);

    for (int i = 2; i < nums.size(); ++i) {
        int temp = last;
        last = current;
        current = max(nums[i] + last, current);
    }

    return current;
}
````
*/

int rob (vector<int>& nums) {
  if (nums.empty()) return 0;

  int last = nums[0];
  int current = max(last, nums[1]);

  for (int i = 2; i < nums.size(); ++i) {
    int temp = last; 
    last = res;
    current = max(temp+nums[i], current);
  }
  return current;
}
