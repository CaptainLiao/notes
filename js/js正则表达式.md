# JavaScript 正则表达式

### 1. `RegExp`对象

有两种方法实例化`RegExp`对象

* 字面量

  `var reg = /\bis\b/g; // 全局匹配单词is`

* 构造函数

  `var reg = new RegEXP('\\bis\\b',g)`

### 2. 修饰符

* g：global全文搜索，不添加，搜索到第一个匹配停止 默认false，只读

* i：ignore case 忽略大小写，                                         默认false，只读

* m：multiple lines 多行搜索                                           默认false，只读

* lastIndex： 是当前表达式匹配内容的最后一个字符的下一个位置

* source：正则表达式的文本字符串

  ````javas
  > var reg1 = /\w/gim;
  > reg1.source
  < "\w"
  ````

  ​

### 3. 元字符

正则表达式由两种基本字符类型组成：

1. 原义文本字符  

   a,b,c,d..

2. 元字符

   *+？$ ^ . |  \  （ ）{ } [ ]

   | \t   | 水平制表符 |
   | ---- | ----- |
   | \v   | 垂直制表符 |
   | \n   | 换行符   |
   | \r   | 回车符   |
   | \0   | 空字符   |
   | \f   | 换页符   |

### 4. 字符类

* 我们可以使用元字符 **[]** 来构建一个简单的类

> 所谓类是指符合某些特征的对象，一个泛指，不是特指某个字符
>
> 表达式`[abc]`把字符a或b或c归为一类，表达式可以匹配这类字符

* 字符取反（^）

> 使用元字符 ^ 创建反向类
>
> 表达式`[^abc]` 表示 不是字符a或b或c的内容

### 5. 范围类

* 使用[a-z]来连接两个字符表示从a到z的任意字符，闭区间，包含a 和 z 本身

  ```javas
  > 'a1b2c3b4'.replace(/[a-z]/g, 'Q');
  < "Q1Q2Q3Q4"
  ```

* 范围类可以连写 `[a-zA-Z]`

  ```JAVAS
  > '2015-11-5'.replace(/[0-9-]/g, 'A')
  < "AAAAAAAAA"
  ```

  ​

### 6.预定义类及边界

#### 6.1 预定义类

| 字符   | 等价类            | 含义               |
| ---- | -------------- | ---------------- |
| .    | [^\r\n]        | 除了回车符和换行符以外的所有字符 |
| \d   | [0-9]          | 数字字符             |
| \D   | [^0-9]         | 非数字字符            |
| \s   | [\t\n\x0B\f\r] | 空白字符             |
| \w   | [a-zA-Z_0-9]   | 单词字符（字母数字下划线）    |
| \W   | [^a-zA-Z0-9_]  | 非单词字符            |

#### 6.2 边界

|  字符  |    含义    |
| :--: | :------: |
|  ^   | 以XXXXX开始 |
|  $   | 以xxxx结束  |
|  \b  |   单词边界   |
|  \B  |  非单词边界   |



### 7. 量词

| 字符    | 含义              |
| ----- | --------------- |
| ？     | 出现零次或一次（最多出现1次） |
| +     | 出现一次或多次         |
| *     | 出现零次或多次（任意      |
| {n}   | 出现n次            |
| {n,m} | 出现n到m次          |
| {n,}  | 至少出现n次          |

### 8.贪婪模式与非贪婪模式

#### 8.1 贪婪模式

在正则表达式中，默认尽可能多的匹配

````javas
> '1234678'.replace(/\d{3,6}/g, 'X')
< "X78"
````

#### 8.2 非贪婪模式

让正则表达谁尽可能少的匹配，也就是说一旦成功匹配就不再继续尝试

**做法很简单，在量词后面加一个 ？即可**

````javas
> '123456789'.match(/\d{3,5}?/g)
< ["123","456","789"]
````

### 9. 分组

#### 9.1 分组

使用 （）可以达到分组的功能，使量词作用于分组

````javas
> 'fayfayfayfsd'.replace(/(fay){3}/g, 'X')
< "Xfsd"
````

#### 9.2 或

使用 | 表示 或

````javas
> 'ByronCasper'.replace(/Byron|Casper/g, 'X')
< "XX"
````

#### 9.3 $引用，捕获分组

* 注意： 一定要加（），用$捕获分组

````JAVAS
> '2016-11-05'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2-$3-$1')
< "05-11-2016"
````

* 忽略分组

  不希望捕获某些分组，只需要在分组内加上 ？：

  `(?:Byron).(ok)`

### 10. 前瞻

* 正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前”
* **前瞻**就是在正则表达式匹配到规则的时候，向前检查是否符合断言，与后瞻/后顾方向相反
* 符合和不符合特定断言称为**肯定/正向**匹配和**否定/负向**匹配
* JavaScript 不支持后顾

| 名称   | 正则                                  | 含义    |
| ---- | ----------------------------------- | ----- |
| 正向前瞻 | exp(?=assert)  // exp表示一个正则，括号内表示断言 |       |
| 负向前瞻 | exp(?!assert)                       |       |
| 正向后顾 | exp(?<=assert)                      | JS不支持 |
| 负向后顾 | exp(?<!assert)                      | JS不支持 |

````javas
> 'a2*34v6'.replace(/\w(?=\d)/g, 'X')
< "X2*X4X6"

> 'a2*34vv'.replace(/\w(?=\d)/g, 'X')
< "X2*X4vv"
````

### 11. test 和 exec 方法

#### 11.1 `RegExp.prototype.test(str)`

* 用于测试字符串参数中是否存在匹配正则表达式模式的字符串
* 存在返回 true ，不存在返回false

````javas
>var reg = /\w/g;
>while(reg.test("ab")){
>  console.log(reg.lastIndex)
>}
< 1
< 2
````



````javas
function deepCopy (p, c) {
    var c = c || {};
    if(typeof p === "object"){
      for(var i in p) {
                if(typeof p[i] === 'object'){
                    c[i] = (p[i] instanceof Array) ? [] : {};
                    deepCopy(p[i], c[i]);
                }else {
                    c[i] = p[i];
                }
            };
    }else {
      c = p;
    }
    return c;
}
var m = "sss"
var n = deepCopy(m)
console.log(n)
````



















